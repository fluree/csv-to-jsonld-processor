{
  "@context": {
    "@vocab": "https://ns.flur.ee/imports#",
    "sequence": {
      "@id": "https://ns.flur.ee/imports#sequence",
      "@container": "@list"
    }
  },
  "@type": "CSVImportManifest",
  "@id": "model/dell",
  "name": "Manifest for Dell Bill of Materials CSV Import",
  "description": "This manifest describes the process for importing a set of CSV files that describe a Dell Bill of Materials Inventory",
  "model": {
    "baseIRI": "http://example.com/dell-bom/terms/",
    "path": "model/",
    "sequence": [
      {
        "path": "main.csv",
        "@type": [
          "CSVImportStep",
          "BasicVocabularyStep" // Basic vocabulary steps expect rows w/ class & property information and then produce class & property data in the model. Each row is a property and may have class data expressing that it is a property existing on that class
        ],
        "overrides": [ // while there is usually a default expectation for column headers (e.g. Class ID, Class Name), overrides allow you to express that a certain column header should be used in place of the default and should be used for a particular purpose
        // the mapTo values can be $Class.ID, $Class.Name, $Class.Description, $Property.ID, $Property.Description, $Property.Type, $Property.TargetClass
          {
            "column": "Custom Class Name Header",
            "mapTo": "$Class.ID"
          },
          {
            "column": "Custom Class Name Header",
            "mapTo": "$Class.Name"
          },
          {
            "column": "Property Name",
            "mapTo": "$Property.ID"
          }
        ],
        "extraItems": [ // extraItems indicates that we should retain values on unexpected columns and map them to a particular IRI. Because the CSV includes data for properties and for classes, you must specify whether the extra item should be written as metadata to the class or to the property
          {
            "column": "Reasoning Logic",
            "mapTo": "http://example.com/dell-bom/terms/reasoningLogic",
            "onEntity": "PROPERTY"
          }
        ]
      },
      {
        "path": "material_class_values_list.csv",
        "@type": [
          "CSVImportStep",
          "SubClassVocabularyStep" // SubClass vocabulary steps only describe data on subClasses of a parent class. The parent class must be specified in the manifest.
        ],
        "subClassOf": [ // the parent class of the subClasses described in this CSV
          "http://example.com/dell-bom/terms/Material"
        ],
        "replaceIdWith": "$Class.Name", // replaceIdWith is an !!important!! element. It indicates that, while all the CSVs will use the column related to $Class.ID to identify an entity (class, property, or instance), we should, at the final point where we serialize the data to JSON, use a replacement columns' cells in order to write the @id/IRI for the entity
        "extraItems": [
          {
            "column": "Category",
            "mapTo": "http://example.com/dell-bom/terms/category",
            "onEntity": "CLASS"
          }
        ]
      },
      {
        "path": "material_features.csv",
        "@type": [
          "CSVImportStep",
          "BasicVocabularyStep"
        ],
        "replaceIdWith": "$Class.Name",
        "extraItems": [
          {
            "column": "Attribute Abbreviation",
            "mapTo": "http://example.com/dell-bom/terms/attributeAbbreviation",
            "onEntity": "PROPERTY"
          },
          {
            "column": "Before / After",
            "mapTo": "http://example.com/dell-bom/terms/beforeAfter",
            "onEntity": "PROPERTY"
          }
        ]
      }
    ]
  },
  "instances": {
    "baseIRI": "http://example.com/dell-bom/ids/",
    "path": "instances/",
    "sequence": [
      {
        "path": "products.csv",
        "@type": [
          "CSVImportStep",
          "BasicInstanceStep"
        ],
        "instanceType": "Product" // instanceType is the class of the instances described in the CSV
      },
      {
        "path": "bill_of_materials.csv",
        "@type": [
          "CSVImportStep",
          "BasicInstanceStep"
        ],
        "instanceType": "BillOfMaterials",
        "ignore": [
          "has Material Class",
          "Material Class Name",
          "Material Class Description",
          "Material Name",
          "Material Unit Price",
          "Lowest Cost Alternative Material Name",
          "Lowest Cost Alternative Material Manufacturer"
        ]
      },
      {
        "path": "materials.csv",
        "@type": [
          "CSVImportStep",
          "SubClassInstanceStep"
        ],
        "instanceType": "Material",
        "subClassProperty": "has Material Class", // IMPORTANT: This is unimplemented and needs to be done. When working with subClass instance data, the manifest step must indicate both the class AND the subclass. This is because for this import, we need to have both @types EXPLICITLY expressed on the entity (e.g. "@type": ["Material", "<reference expressed on the has Material Class property>"]). 
        // Keep in mind that the reference may be the "original" reference used in the CSVs (which in the code is expressed with the IdOpt enum, which accommodates both the original value and the final value).
        "ignore": [
          "Manufacturer Name",
          "Material Class Name"
        ]
      },
      {
        "path": "material_instances_with_properties.csv",
        "@type": [
          "CSVImportStep",
          "PropertiesInstanceStep" // IMPORTANT: This is unimplemented and needs to be done. The difference between this and the BasicInstanceStep is that the CSVs for PropertiesInstanceStep will have a column specifying a particular property by its ID and another column specifying the value for that property. This is useful for when you have a lot of properties to describe on an instance, and those properties are not the same (e.g. can't re-use common column names)
          // In this case, we expect a column Entity ID, a column Property ID, and a column Property Value
        ],
        "instanceType": "Material",
        "ignore": [
          "Material Name",
          "Material Feature"
        ]
      }
    ]
  }
}
